import base64
import os
import warnings

import eagerpy as ep
import foolbox as fb
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
from PIL import Image
from tensorflow.keras.applications.resnet50 import decode_predictions

"""
1. show_image()
    Show image using matplotlib and print the label output by tensorflow model

2. is_adv()
    Return if an adversarial image generated by attacker is real adversarial,
        True: only if the top 1 label of the adversarial image not the same as the original top 1 label

3. save_image()
    Save the tersor type image as file type.
"""


def image_preprocessing_ver_fb(path, shape=(224, 224), data_format='channels_last'):
    """
    Based on foolbox.utils._samples.
    """
    image = Image.open(path)
    image = image.resize(shape)
    image = np.asarray(image, dtype=np.float32)
    # print("-- Original image from Ditto image_preprocessing_ver_fb(): ", image, type(image), len(image[0]))
    if image.ndim == 2:
        image = image[..., np.newaxis]
    assert image.ndim == 3
    if data_format == "channels_first":
        image = np.transpose(image, (2, 0, 1))
    return image


def image_preprocessing_ver_hc(paths, shape=(224, 224), data_format='channels_last'):
    """
    Based on https://bbs.huaweicloud.com/blogs/192004.
    """
    images = []
    for file_name in paths:
        image = Image.open(file_name)
        image.resize(shape)
        image = np.array(image, dtype=np.float32)
        if image.ndim == 2:
            image = image[..., np.newaxis]
        assert image.ndim == 3
        if data_format == "channels_first":
            image = np.transpose(image, (2, 0, 1))
        images.append(image)
    images = tf.convert_to_tensor(images, dtype=tf.dtypes.float32)
    return images


def show_image(path, model, img=None, title='Image', need_predict=True, dataset=None):
    """
    Based on foolbox.utils._samples & foolbox.utils.samples: return "images, labels" as the same foolbox's sample API.
    """

    if img is None:
        image = image_preprocessing_ver_fb(path)
    else:
        image = img

    if need_predict:
        label = model.predict(image[np.newaxis, :, :, ::-1])

        # Print out the label code (correct one), and top 5 decoded results with prob.
        print("-- Image top label: ", np.argmax(label), " --\n")
        if dataset == 'imagenet':
            print("-- Type of Tensorflow style label: ", type(label))
            print(decode_predictions(label, top=5))
    else:
        label = None

    plt.figure()
    plt.subplot(1, 1, 1)
    plt.title(title)
    plt.imshow(image / 255)  # division by 255 to convert [0, 255] to [0, 1]
    plt.axis('off')
    plt.show()
    return image, label


def is_adv(original_label, adv_label):  # array of probabilities
    # if decode_predictions(original_label, top=1)[0][0][0] != decode_predictions(adv_label, top=1)[0][0][0]:
    if np.argmax(ep.astensor(original_label).numpy()) != np.argmax(ep.astensor(adv_label).numpy()):
        return True
    return False


def save_image(image, filename, shape=None):
    # from tensor tpye to file
    image = ep.astensor(image).numpy()
    image = Image.fromarray(np.uint8(image))
    if shape is not None:
        image.resize(shape)
    image.save(filename)


def setup_tensorboard(dirname, imgs, count):
    # [count] now is not useful
    # only show one image

    # Reshape the image for the Summary API.
    img = np.reshape(imgs[0], (-1, 224, 224, 3))

    # Sets up a timestamped log directory.
    global timestamped_log_root_directory
    logdir = timestamped_log_root_directory + dirname

    # Creates a file writer for the log directory.
    file_writer = tf.summary.create_file_writer(logdir)

    # Using the file writer, log the reshaped image.
    with file_writer.as_default():
        tf.summary.image(dirname, img, step=0)

    return logdir


def b64_encode_image(path):
    with open(path, "rb") as image:
        base64_image = base64.b64encode(image.read())
        image.close()
        os.remove(path)
        return base64_image.decode()


def json_to_sensor():
    warnings.warn("Not implemented.")
    pass


def version():
    print("---- Tensorflow版本: ", tf.__version__, " ----")
    print("---- FoolBox版本: ", fb.__version__, " ----")
